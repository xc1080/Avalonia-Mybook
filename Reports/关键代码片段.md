# 关键代码片段（精简）

此文档收集项目中用于说明关键技术点的精简代码段（每段 ≤10 行）与简短说明，方便复制到报告或笔记中。

---

**技术点1：SQLite（初始化与迁移）**

说明：建表并把空字符串 JSON 迁移为 NULL，避免反序列化异常。

```csharp
var cmd = conn.CreateCommand();
cmd.CommandText = @"
CREATE TABLE IF NOT EXISTS Chapters (Id TEXT PRIMARY KEY, Title TEXT, OrderIndex INTEGER, Description TEXT);
CREATE TABLE IF NOT EXISTS Nodes (Id TEXT PRIMARY KEY, ChapterId TEXT, Type INTEGER, Text TEXT, Choices TEXT);
CREATE TABLE IF NOT EXISTS GameStates (Slot TEXT PRIMARY KEY, Data TEXT, UpdatedAt TEXT);
";
await cmd.ExecuteNonQueryAsync();
// 后续有 cleanup 将空字符串 JSON => NULL
```

---

**技术点1：SQLite（保存节点的关键片段）**

说明：参数化保存，Choices 以 JSON blob 存储；防止跨章节 id 覆盖。

```csharp
cmd.CommandText = @"INSERT INTO Nodes (Id, ChapterId, Type, Text, Choices) VALUES ($id,$cid,$type,$text,$choices)
ON CONFLICT(Id) DO UPDATE SET ChapterId=$cid, Type=$type, Text=$text, Choices=$choices";
cmd.Parameters.AddWithValue("$id", node.Id);
cmd.Parameters.AddWithValue("$choices", node.Choices==null? DBNull.Value : (object)JsonSerializer.Serialize(node.Choices));
await cmd.ExecuteNonQueryAsync();
```

---

**技术点2：脚本解析器（去除 Markdown 围栏 + 前缀 node id）**

说明：剥离 ``` 围栏，生成节点 id 时以章节 id 为前缀保证跨章唯一。

```csharp
var rawLines = script.Split('\n').Select(l => l.TrimEnd('\r')).ToList();
if (rawLines.Count>0 && rawLines[0].TrimStart().StartsWith("```")) { rawLines.RemoveAt(0); rawLines.RemoveAt(rawLines.Count-1); }
var nodeId = rawId != null ? (rawId.StartsWith(chapterId+"_")? rawId : $"{chapterId}_{rawId}") : $"{chapterId}_node_{nodeIndex:D4}";
```

---

**技术点3：选项模型（一次性/条件支持）**

说明：每个选项包含唯一 Id、一次性标记和条件表达式字段。

```csharp
public class StoryChoice {
  public string Id { get; set; } = System.Guid.NewGuid().ToString();
  public string Text { get; set; } = string.Empty;
  public string TargetNodeId { get; set; } = string.Empty;
  public string? TargetChapterId { get; set; }
  public string? Condition { get; set; }
  public bool IsOneTime { get; set; } = false;
}
```

---

**技术点4：编辑器端自动修正（NormalizeNodeChoicesAsync）**

说明：保存前把误填在 `TargetChapterId` 的 node-id 移到 `TargetNodeId`，并提示作者复核。

```csharp
foreach(var choice in node.Choices){
  if(string.IsNullOrWhiteSpace(choice.TargetNodeId) && !string.IsNullOrWhiteSpace(choice.TargetChapterId)){
    var possible = await _dataService.GetNodeAsync(choice.TargetChapterId!);
    if(possible!=null){ choice.TargetNodeId=possible.Id; choice.TargetChapterId=possible.ChapterId; corrected++; continue; }
    if(choice.TargetChapterId!.Contains("_node_")){
      choice.TargetNodeId=choice.TargetChapterId;
      choice.TargetChapterId=choice.TargetChapterId.Split(new[]{"_node_"},StringSplitOptions.None)[0];
      corrected++; }
  }
}
if(corrected>0) await ShowInfoDialog($"已自动修正 {corrected} 个选项目标。");
```

---

**技术点5：运行时导航回退（优先 TargetNodeId，模糊查找回退）**

说明：优先使用 `TargetNodeId`；若无则按 `TargetChapterId`；若字段看起来像 node id，则当作 node id 去查找并导航。

```csharp
if(!string.IsNullOrWhiteSpace(choice.TargetNodeId)) await NavigateToNodeAsync(choice.TargetNodeId);
else if(!string.IsNullOrWhiteSpace(choice.TargetChapterId)){
  if(choice.TargetChapterId.Contains("_node_")){
    var node = await _dataService.GetNodeAsync(choice.TargetChapterId);
    if(node!=null) await NavigateToNodeAsync(node.Id);
    else await LoadChapterStart(choice.TargetChapterId.Split(new[]{"_node_"},...)[0]);
  } else await LoadChapterStart(choice.TargetChapterId);
}
```

---

**技术点6：文件日志（FileLogger 调用示例）**

说明：GUI 无控制台时写文件，便于离线排查导航与条件求值问题。

```csharp
File.AppendAllText(Path.Combine("Stories","runtime.log"), $"{DateTime.UtcNow:o} ChooseAsync Id={choice.Id} TargetChapter={choice.TargetChapterId} TargetNode={choice.TargetNodeId}\n");
```

---

如果需要我可以把这份文档也 `git add`/`git commit`（默认提交到当前分支）。
